# task-for-choosing-a-specialization

### **Задача**:

Написать программу, которая из имеющегося массива строк формирует массив из строк, длина которых меньше либо равна 3 символа. Первоначальный массив можно ввести с клавиатуры, либо задать на старте выполнения алгоритма. При решении не рекомендуется пользоваться коллекциями, лучше обойтись исключительно массивами.

### **Примеры**:

["hello", "2", "world", ":-)"] $\rightarrow$ ["2", ":-)"]

["1234", "1567", "-2", "computer science"] $\rightarrow$ ["-2"]

### **Список задач**
* [x] Создать репозиторий на GitHub
* [x] Нарисовать блок-схему алгоритма 
* [x] Снабдить репозиторий оформленным текстовым описанием решения (файл README.md)
* [x] Написать программу, решающую поставленную задачу
* [x] Использовать контроль версий в работ над этим небольшим проектом (недолжно быть так, что всё залито одним коммитом, как минимум этапы 2,3 и 4 должны быть расположены в разных коммитах)


## **Текстовое описание решения**

Для решения поставленной задачи было сформированно несколько методов:

**GetNewArr**

Метод GetNewArr() формирует массив строковых данных запрашивая их у пользовотеля. Процесс работы следующий:
1. Создаётся новый строковый пустой массив: `string[] arr = new string[0]`
2. Дополнительно задаётся целочисленная переменная для индекса: `int ind = 0`
3. Запускается цикл с условием выхода нажатие Enter без ввода данных
4. Во временную переменную записываются данные введённые пользователем `string tmpText = Console.ReadLine()`
5. Если данные не были введены цикл прерывается `if (tmpText == string.Empty) break`
6. Если пользовтель ввёл данные:
   1. Идёт проверка на наличие свободной позиции в массиве `if (ind == arr.Length)`
   2. Если позиции нет вызывается метод GrowArr() и его результат присваевается массиву ` arr = GrowArr(arr)`
   3. Иначе в массиве под индексом записывается введённое значение, а индекс увеличивается на единицу
 
```
arr[ind] = tmpText;
ind++;
```
7.  Метод возвращает строковый массив `return arr`

**GrowArr**
`static string[] GrowArr(string[] oldArr)`
Метод получает массив и увеличивает его размер на единицу. Процесс работы следующий:
1. Получаем массив в аргументе
2. Создаётся новый массив с размером на единицу больше `string[] newArr = new string[oldArr.Length + 1]`
3. Рекурсивно новый массив заполняется элементами из старого `for (int i = 0; i < oldArr.Length; i++) newArr[i]=oldArr[i]`
4. Возвращается новый массив `return newArr`

**ShowArr**

Метод получает массив и отображает каждый элемент в массиве

**ChoiceValuesInArr**

Так как согласно задаче нужно сформировать новый массив соответствующий указанным условиям из предоставленного пользователем, данный метод формирует новый массив. Ниже процесс работы:
1. Получаем массив и максимальную длину элементов для выборки в качестве аргументов `string[] arr, int choiceLength`
2. Создаём новый пустой строковый массив `string[] newArr = new string[0]`
3. Дополнительно задаётся целочисленная переменная для индекса `int ind = 0`
4. Проходим по полученному массиву 
5. Если элемент соответствует условию, то выполняются следуещие действия:
   1. Проверяем есть свободная ячейка в массиве под текущим индексом, если нет вызывается метод GrowArr() для его увеличения
   2. Добавляем элемент по указанному индексу
   3. Увеличиваем индекс на единицу
```
for (int i = 0 ; i < arr.Length; i++)
    {
        if (arr[i].Length <= choiceLength)
        {
            if (ind == newArr.Length) newArr = GrowArr(newArr); 
            newArr[ind] = arr[i];
            ind++;
        }
    }
```
6. Возвращаем массив `return newArr`

**GetLengthElements**

метод запрашивает и возвращает у пользователя целое число для использования в последующей выборке данных из массива